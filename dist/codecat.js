// Generated by CoffeeScript 1.11.1
(function() {
  var CodeCat, EOL, Path, Readline, Writable, createReadStream, createWriteStream, readFileSync, ref, statSync,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  EOL = require('os').EOL;

  Readline = require('readline');

  ref = require('fs'), readFileSync = ref.readFileSync, createReadStream = ref.createReadStream, createWriteStream = ref.createWriteStream, statSync = ref.statSync;

  Writable = require('stream').Writable;

  Path = require('path');

  module.exports = CodeCat = (function() {
    var callbackForEach, discernOptions, ensureStream, getSourceCommenter, isString, joinFiles, regexpEscape, tryOrNull;

    function CodeCat(source, options) {
      var commenter, encoding, getDirectiveRegExp, prefix, ref1, ref2, ref3;
      if (options == null) {
        options = {};
      }
      prefix = (ref1 = options.prefix) != null ? ref1 : 'codecat', commenter = (ref2 = options.commenter) != null ? ref2 : getSourceCommenter(source), encoding = (ref3 = options.encoding) != null ? ref3 : 'utf8';
      getDirectiveRegExp = function(directive) {
        return new RegExp("^\\s*" + commenter + "\\s*@" + prefix + "-" + directive + "\\s+([\"']?)(.+?)\\1(\\s|$)");
      };
      Object.defineProperties(this, {
        source: {
          value: source
        },
        prefix: {
          value: prefix
        },
        encoding: {
          value: encoding
        },
        prependRegexp: {
          value: getDirectiveRegExp('prepend')
        },
        appendRegexp: {
          value: getDirectiveRegExp('append')
        }
      });
    }

    CodeCat.prototype.findConcats = function(options, callback) {
      var append, concats, lineReader, prepend, ref1, ref2;
      ref1 = discernOptions(options, callback), options = ref1[0], callback = ref1[1];
      ref2 = concats = {
        prepend: [],
        append: []
      }, prepend = ref2.prepend, append = ref2.append;
      lineReader = Readline.createInterface({
        input: createReadStream(this.source, {
          encoding: this.encoding
        })
      });
      lineReader.on('line', (function(_this) {
        return function(line) {
          var match, ref3, ref4;
          if (match = (ref3 = line.match(_this.prependRegexp)) != null ? ref3[2] : void 0) {
            return prepend.push(match);
          } else if (match = (ref4 = line.match(_this.appendRegexp)) != null ? ref4[2] : void 0) {
            return append.push(match);
          }
        };
      })(this));
      return lineReader.on('close', function() {
        return typeof callback === "function" ? callback(concats) : void 0;
      });
    };

    CodeCat.prototype.concat = function(options, callback) {
      var concatted, ref1, stream, write;
      ref1 = discernOptions(options, callback), options = ref1[0], callback = ref1[1];
      concatted = '';
      write = function(chunk, encoding, cb) {
        concatted += chunk;
        return typeof cb === "function" ? cb(null) : void 0;
      };
      stream = new Writable({
        write: write
      });
      return this.concatTo(stream, options, function(error) {
        return typeof callback === "function" ? callback(concatted) : void 0;
      });
    };

    CodeCat.prototype.concatTo = function(dest, options, callback) {
      var recursive, ref1, ref2;
      ref1 = discernOptions(options, callback), options = ref1[0], callback = ref1[1];
      recursive = (ref2 = options.recursive) != null ? ref2 : false;
      return ensureStream(dest, {
        defaultEncoding: this.encoding
      }, (function(_this) {
        return function(stream, end) {
          return _this.findConcats(function(concats) {
            var error, paths, resConcats;
            error = null;
            resConcats = _this._resolveConcats(concats, recursive);
            paths = slice.call(resConcats.prepend).concat([_this.source], slice.call(resConcats.append));
            return joinFiles(paths, _this.encoding, stream, options, function() {
              return typeof callback === "function" ? callback(error) : void 0;
            });
          });
        };
      })(this));
    };

    CodeCat.Commenters = {
      '': '//',
      js: '//',
      coffee: '#'
    };

    CodeCat.prototype._resolveConcats = function(concats, recursive) {
      var files, resolved, type;
      resolved = {};
      for (type in concats) {
        if (!hasProp.call(concats, type)) continue;
        files = concats[type];
        resolved[type] = files.map((function(_this) {
          return function(c) {
            return _this._resolveConcat(c, recursive);
          };
        })(this)).filter(function(c) {
          return c != null;
        });
      }
      return resolved;
    };

    CodeCat.prototype._resolveConcat = function(concat, recursive) {
      var relPath, resNode, srcDir, stats;
      srcDir = Path.dirname(this.source);
      relPath = Path.join(srcDir, concat);
      stats = tryOrNull(function() {
        return statSync(relPath);
      });
      if (!(stats != null ? stats.isFile() : void 0)) {
        resNode = function() {
          return require.resolve(concat);
        };
        return tryOrNull(resNode, "Invalid file or node module \"" + concat + "\"");
      } else if (recursive) {
        return new CodeCat(relPath, this.options);
      } else {
        return relPath;
      }
    };

    getSourceCommenter = function(source) {
      var commenter, ext;
      ext = Path.extname(source).slice(1);
      commenter = CodeCat.Commenters[ext];
      if (commenter != null) {
        return regexpEscape(commenter);
      } else {
        return '';
      }
    };

    joinFiles = function(files, encoding, stream, options, finishedFn) {
      var ref1, separator;
      if (options == null) {
        options = {};
      }
      separator = (ref1 = options.separator) != null ? ref1 : EOL;
      return callbackForEach(files, finishedFn, function(file, notFirst, done) {
        var output, writeEndCb;
        output = (notFirst && separator) || '';
        writeEndCb = file instanceof CodeCat ? function() {
          return file.concatTo(stream, options, done);
        } : (output += readFileSync(file, {
          encoding: encoding
        }), done);
        return stream.write(output, encoding, writeEndCb);
      });
    };

    ensureStream = function(dest, options, fn) {
      var end, ref1, stream;
      ref1 = discernOptions(options, fn), options = ref1[0], fn = ref1[1];
      if (isString(dest)) {
        stream = createWriteStream(dest, options);
        end = function(endCb) {
          return stream.end(endCb);
        };
        return stream.once('open', function() {
          return fn(stream, end);
        });
      } else {
        end = function(endCb) {
          return typeof endCb === "function" ? endCb() : void 0;
        };
        return fn(dest, end);
      }
    };

    regexpEscape = function(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    };

    isString = function(val) {
      return (typeof val === 'string') || (val instanceof String);
    };

    discernOptions = function(options, fn) {
      if (options instanceof Function) {
        return [{}, options];
      } else {
        return [options != null ? options : {}, fn];
      }
    };

    tryOrNull = function(tryFn, error) {
      try {
        return tryFn();
      } catch (error1) {
        if (error != null) {
          console.log(error);
        }
        return null;
      }
    };

    callbackForEach = function(collection, done, callback) {
      var callbackCurrent, current, ref1, total;
      ref1 = [collection.length, 0], total = ref1[0], current = ref1[1];
      return (callbackCurrent = function() {
        var called, item;
        item = collection[current];
        called = false;
        return callback(item, current, function(error) {
          if (error != null) {
            console.error(error);
          }
          if (!called) {
            called = true;
            if (++current >= total) {
              return done();
            } else {
              return callbackCurrent();
            }
          }
        });
      })();
    };

    return CodeCat;

  })();

}).call(this);
