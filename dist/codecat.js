// Generated by CoffeeScript 1.11.1
(function() {
  var CodeCat, EOL, Path, Readline, Writable, createReadStream, createWriteStream, readFileSync, ref,
    slice = [].slice,
    hasProp = {}.hasOwnProperty;

  EOL = require('os').EOL;

  Readline = require('readline');

  ref = require('fs'), readFileSync = ref.readFileSync, createReadStream = ref.createReadStream, createWriteStream = ref.createWriteStream;

  Writable = require('stream').Writable;

  Path = require('path');

  module.exports = CodeCat = (function() {
    var discernOptions, ensureStream, getSourceCommenter, isString, joinFiles, mapConcats, regexpEscape;

    function CodeCat(source, options) {
      var commenter, encoding, getDirectiveRegExp, prefix, ref1, ref2, ref3;
      if (options == null) {
        options = {};
      }
      prefix = (ref1 = options.prefix) != null ? ref1 : 'codecat', commenter = (ref2 = options.commenter) != null ? ref2 : getSourceCommenter(source), encoding = (ref3 = options.encoding) != null ? ref3 : 'utf8';
      getDirectiveRegExp = function(directive) {
        return new RegExp("^\\s*" + commenter + "\\s*@" + prefix + "-" + directive + "\\s+([\"']?)(.+?)\\1(\\s|$)");
      };
      Object.defineProperties(this, {
        source: {
          value: source
        },
        prefix: {
          value: prefix
        },
        commenter: {
          value: commenter
        },
        encoding: {
          value: encoding
        },
        prependRegexp: {
          value: getDirectiveRegExp('prepend')
        },
        appendRegexp: {
          value: getDirectiveRegExp('append')
        }
      });
    }

    CodeCat.prototype.findConcats = function(options, callback) {
      var append, concats, lineReader, prepend, ref1, ref2, ref3, ref4, relative;
      ref1 = discernOptions(options, callback), (ref2 = ref1[0], relative = (ref3 = ref2.relative) != null ? ref3 : false), callback = ref1[1];
      ref4 = concats = {
        prepend: [],
        append: []
      }, prepend = ref4.prepend, append = ref4.append;
      lineReader = Readline.createInterface({
        input: createReadStream(this.source, {
          encoding: this.encoding
        })
      });
      lineReader.on('line', (function(_this) {
        return function(line) {
          var match, ref5, ref6;
          if (match = (ref5 = line.match(_this.prependRegexp)) != null ? ref5[2] : void 0) {
            return prepend.push(match);
          } else if (match = (ref6 = line.match(_this.appendRegexp)) != null ? ref6[2] : void 0) {
            return append.push(match);
          }
        };
      })(this));
      return lineReader.on('close', (function(_this) {
        return function() {
          if (relative) {
            concats = mapConcats(concats, _this.getRelativePath, _this);
          }
          return typeof callback === "function" ? callback(concats) : void 0;
        };
      })(this));
    };

    CodeCat.prototype.concat = function(options, callback) {
      var concatted, ref1, stream, write;
      ref1 = discernOptions(options, callback), options = ref1[0], callback = ref1[1];
      concatted = '';
      write = function(chunk, encoding, cb) {
        concatted += chunk;
        return typeof cb === "function" ? cb(null) : void 0;
      };
      stream = new Writable({
        write: write
      });
      return this.concatTo(stream, options, function(error) {
        return typeof callback === "function" ? callback(concatted) : void 0;
      });
    };

    CodeCat.prototype.concatTo = function(dest, options, callback) {
      var ref1, ref2, ref3, separator;
      ref1 = discernOptions(options, callback), (ref2 = ref1[0], separator = (ref3 = ref2.separator) != null ? ref3 : EOL), callback = ref1[1];
      return this.findConcats({
        relative: true
      }, (function(_this) {
        return function(concats) {
          var error, paths;
          error = null;
          paths = slice.call(concats.prepend).concat([_this.source], slice.call(concats.append));
          return ensureStream(dest, {
            defaultEncoding: _this.encoding
          }, function(stream) {
            joinFiles(paths, this.encoding, separator, stream);
            return stream.end(function() {
              return typeof callback === "function" ? callback(error) : void 0;
            });
          });
        };
      })(this));
    };

    CodeCat.prototype.getRelativePath = function(file) {
      var sourceDir;
      sourceDir = Path.dirname(this.source);
      return Path.join(sourceDir, file);
    };

    CodeCat.Commenters = {
      '': '//',
      js: '//',
      coffee: '#'
    };

    getSourceCommenter = function(source) {
      var commenter, ext;
      ext = Path.extname(source).slice(1);
      commenter = CodeCat.Commenters[ext];
      if (commenter != null) {
        return regexpEscape(commenter);
      } else {
        return '';
      }
    };

    joinFiles = function(paths, encoding, separator, stream) {
      return paths.forEach(function(path, notFirst) {
        var output;
        output = (notFirst && separator) || '';
        output += readFileSync(path, {
          encoding: encoding
        });
        return stream.write(output);
      });
    };

    ensureStream = function(dest, options, fn) {
      var ref1, stream;
      ref1 = discernOptions(options, fn), options = ref1[0], fn = ref1[1];
      if (isString(dest)) {
        stream = createWriteStream(dest, options);
        return stream.once('open', function() {
          return fn(stream);
        });
      } else {
        return fn(dest);
      }
    };

    mapConcats = function(concats, map, thisArg) {
      var files, mapped, type;
      mapped = {};
      for (type in concats) {
        if (!hasProp.call(concats, type)) continue;
        files = concats[type];
        mapped[type] = files.map(map, thisArg);
      }
      return mapped;
    };

    regexpEscape = function(str) {
      return str.replace(/[\-\[\]\/\{\}\(\)\*\+\?\.\\\^\$\|]/g, '\\$&');
    };

    isString = function(val) {
      return (typeof val === 'string') || (val instanceof String);
    };

    discernOptions = function(options, fn) {
      if (options instanceof Function) {
        return [{}, options];
      } else {
        return [options != null ? options : {}, fn];
      }
    };

    return CodeCat;

  })();

}).call(this);
